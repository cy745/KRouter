package com.zhangke.krouter.compiler

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.Nullability
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.TypeVariableName
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.buildCodeBlock
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import com.zhangke.krouter.annotation.Destination
import com.zhangke.krouter.compiler.ext.asClassDeclaration
import com.zhangke.krouter.compiler.ext.requireAnnotation

/**
 * 最终生成示例
 *
 * ```kotlin
 * package com.zhangke.krouter.generated
 *
 * import com.zhangke.krouter.KRouterRegister
 * import com.zhangke.krouter.test.MainScreen
 * import com.zhangke.krouter.test.SettingsScreen
 * import com.zhangke.krouter.test.TestScreen
 * import kotlin.reflect.KClass
 *
 * /**
 *  * This class is generated by KRouter, do not modify it.
 *  */
 * private class KRouterInjectMap : KRouterRegister {
 *     override fun inject(): Map<String, List<KClass<*>>> = mapOf(
 *         "com.zhangke.krouter.test.Screen" to listOf(TestScreen::class, MainScreen::class),
 *         "com.zhangke.krouter.test.TabScreen" to listOf(SettingsScreen::class)
 *     )
 * }
 * ```
 *
 * 真正实现路由注入的处理器，继承自KRouterCollectProcessor
 * 收集完所在模块后才会执行注入操作
 */
class KRouterInjectProcessor(
    environment: SymbolProcessorEnvironment
) : KRouterCollectProcessor(environment) {

    @OptIn(KspExperimental::class)
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val resultList = super.process(resolver)

        // 若存在生成的文件，则说明收集到了路由信息，还会触发一次process，此时可跳过注入操作
        if (environment.codeGenerator.generatedFile.isNotEmpty()) {
            return resultList
        }

        val generatedItems = resolver.getDeclarationsFromPackage(GENERATED_SHARED_PACKAGE)
        val propertiesItems = generatedItems
            .mapNotNull { (it as? KSClassDeclaration)?.getDeclaredProperties() }
            .flatten()

        val collectedMap = propertiesItems.map { property ->
            val propertyClazz = property.type
                .resolve()
                .declaration
                .asClassDeclaration()

            propertyClazz
        }.toList()

        writeToFile(environment.codeGenerator, collectedMap)

        return resultList
    }

    private fun writeToFile(
        codeGenerator: CodeGenerator,
        collectedMap: List<KSClassDeclaration>
    ) {
        if (collectedMap.isEmpty()) return

        val codeBlock = CodeBlock.builder()
            .beginControlFlow("return when (baseRoute)")

        collectedMap.forEach { clazz ->
            val annotation = clazz.requireAnnotation<Destination>()

            val routers = annotation.arguments
                .firstOrNull { it.name?.asString() == "router" }
                ?.let { (it.value as? ArrayList<*>)?.filterIsInstance<String>() }
                ?: return@forEach

            val condition = routers.joinToString(separator = ", ") { "\"$it\"" }

            val parameters = clazz.primaryConstructor?.parameters
                ?: emptyList()

            val code = buildCodeBlock {
                val parameterCode = parameters.map { parameter ->
                    val paramAnnotation = parameter.annotations.firstOrNull()

                    // 是否必须填写的参数，其次若没有默认值，则为必填
                    val isRequired = paramAnnotation?.arguments
                        ?.firstOrNull { it.name?.asString() == "required" }
                        ?.value == true || !parameter.hasDefault

                    // 参数的类型
                    val parameterType = parameter.type.resolve()

                    // 是否为可空类型
                    val isNullable = parameterType.nullability !=
                            Nullability.NOT_NULL

                    // 参数的映射名称
                    val parameterName = paramAnnotation?.arguments
                        ?.firstOrNull { it.name?.asString() == "name" }
                        ?.let { it.value as? String }
                        ?.takeIf(String::isNotBlank)
                        ?: parameter.name?.asString()

                    if (isRequired) {
                        addStatement(
                            "require(params.containsKey(%S)) { %S }", parameterName,
                            "Parameter $parameterName is required."
                        )
                    }

                    addStatement(
                        "val %L = params[%S] as? %T",
                        parameterName,
                        parameterName,
                        parameterType.toClassName()
                    )

                    if (!isNullable && !parameter.hasDefault) {
                        addStatement(
                            "require(%L != null) { %S }", parameterName,
                            "Parameter $parameterName can not be null."
                        )
                    }

                    "$parameterName = $parameterName".let {
                        if (parameter.hasDefault) "$it ?: TOINJECT()"
                        else it
                    }
                }

                val parameterCodeResult = parameterCode.joinToString(separator = ",\n")
                addStatement("%T(%L)", clazz.toClassName(), parameterCodeResult)
            }

            codeBlock.beginControlFlow("$condition -> { params ->")
                .add(code)
                .endControlFlow()
        }

        codeBlock.addStatement("else -> throw IllegalArgumentException(%S)", "Route Not Found.")
            .endControlFlow()

        val mapType = LambdaTypeName.get(
            receiver = null,
            returnType = Any::class.asTypeName(),
            parameters = arrayOf(
                Map::class.asClassName()
                    .parameterizedBy(
                        String::class.asTypeName(),
                        Any::class.asTypeName()
                    )
            )
        )

        val getMapFuncSpec = FunSpec.builder("getMap")
            .addParameter("baseRoute", type = String::class)
            .returns(mapType)
            .addCode(codeBlock.build())
            .build()

        val className = "KRouterInjectMap"
        val classSpec = TypeSpec.objectBuilder(className)
            .addKdoc(CLASS_KDOC)
            .addFunction(getMapFuncSpec)
            .build()

        // 占位函数
        val toInjectFunc = FunSpec.builder("TOINJECT")
            .addModifiers(KModifier.PRIVATE)
            .addTypeVariable(TypeVariableName("T", Any::class))
            .returns(TypeVariableName("T"))
            .addCode("throw IllegalArgumentException(%S)", "Not Injected.")
            .build()

        val fileSpec = FileSpec.builder(GENERATED_SHARED_PACKAGE, className)
            .addFunction(toInjectFunc)
            .addType(classSpec)
            .indent("    ")
            .build()

        // 将涉及到的类所涉及的文件作为依赖传入，方便增量编译
        val dependencies = collectedMap
            .mapNotNull { it.containingFile }
            .distinct()
            .toTypedArray()

        kotlin.runCatching {
            fileSpec.writeTo(
                codeGenerator = codeGenerator,
                dependencies = Dependencies(aggregating = false, *dependencies)
            )
        }
    }
}